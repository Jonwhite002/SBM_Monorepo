# Wheel Speed Sensor Preliminary Code

## <u>Introduction<\u>
Hall effect sensors read individual magnetic pulses, and these pulses tend to occur really fast. Like, 15 KHz fast. A hall effect sensor cannot simply be programmed using a timer such as millisDelay. Instead, an interrupt needs to be used. Unfortunately, programming an interrupt into a node's main code would interfere with the CAN timing, so these sensors have been put into their own circuit that consists of an ATMEGA328P (which is just a stripped down Arduino Uno), and an external 16 MHz timing crystal. This wheel speed circuit interfaces with the CAN board via I2C.

## <ins>Write Code</ins>
The ATMEGA chip only has two interrupt pins, which means that it can only read in two wheel speeds. This is fine, as both the front and rear of the car has two wheels each. When the chip reads a pulse, it calls an ISR (Interrupt Service Routine) function, which begins a timer. This timer ends and subsequently repeats when it reads another pulse. The time that it took to read between two pulses is what yields you your wheel speed, after doing some quick math of course. After both wheel speeds are read, they're sent off via I2C to the main node.

I wrote a function named ```write_msg``` to make it simpler to send these messages. The first argument, ```unit16_t x```, takes an unsigned integer with a length of 16 bits (two bytes). This is the wheel speed value that you're going to want to send. I made it 16 bits so that you can send numbers up to 65,536. You won't need that of course unless you're shooting this damn car into space, but 8 bits (max value of 256) wasn't going to cut it. The second argment, ```*Arr```, is just a dynamically allocated array to store your bits. The last argument, ```int start_bit```, tells the program where in the message (or array, in this case) you want to begin writing your information. Inside the program, you should note some interesting operators. The ```>>>``` operator means that you're shifting the bits to the right to begin writing, and the ```& 0xFF``` is a byte of value ```11111111``` which clears everything before it. If you're interested, look into bitwise operation for more details.

## <ins>Read Code</ins>
The read code, as you might of guessed, reads in the data from the wheel speed circuit via I2C. This code effctively does the same thing as the write code, just backwards. When it detects that wheel speed information is available, it reads the raw data into an array ```msgRead```. You can't just use this by itself however, because it only has the raw bit data. The function ```read_msg``` takes ```msgRead``` as an input, and turns the bits back into useable numbers.